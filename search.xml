<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hadoop</title>
    <url>/2020/05/09/Hadoop%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/river-5134258_1920.jpg" alt=""></p>
<a id="more"></a>

<h3 id="jdk安装"><a href="#jdk安装" class="headerlink" title="jdk安装"></a>jdk安装</h3><p>系统：CentOS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看yum包含的jdk版本</span></span><br><span class="line">[root@ ~]# yum search java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装JDK</span></span><br><span class="line">[root@ ~]# yum install java-1.8.0-openjdk-devel.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量前，需要定位到jdk安装目录</span></span><br><span class="line">[root@ ~]# which java</span><br><span class="line">/usr/bin/java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再找到/usr/bin/java的超链接位置发现还是超链接</span></span><br><span class="line">[root@ ~]# ls -lrt /usr/bin/java</span><br><span class="line">/usr/bin/java -&gt; /etc/alternatives/java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对超链接再次查询，发现最终位置</span></span><br><span class="line">[root@ ~]# ls -lrt /etc/alternatives/java</span><br><span class="line">/etc/alternatives/java -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el8_1.x86_64/jre/bin/java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">[root@ ~]# vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置下列信息，JAVA_HOME需要配置为刚查询出来的jdk目录</span></span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el8_1.x86_64/</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使配置生效</span></span><br><span class="line">[root@ ~]# source /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="Hadoop安装"><a href="#Hadoop安装" class="headerlink" title="Hadoop安装"></a>Hadoop安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载包</span></span><br><span class="line">[root@ ~]# wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-3.1.3/hadoop-3.1.3.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">[root@ ~]# tar -zxvf hadoop-3.1.3.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置</span></span><br><span class="line">[root@ ~]# cd /hadoop-3.1.3/etc/hadoop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 三个配置文件配置core-site.xml，hdfs-site.xml，mapred-site.xml</span></span><br></pre></td></tr></table></figure>



<h2 id="Hadoop运行模式"><a href="#Hadoop运行模式" class="headerlink" title="Hadoop运行模式"></a>Hadoop运行模式</h2><ul>
<li>本地模式</li>
<li>伪分布式</li>
<li>完全分布式</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数字金额大写转换</title>
    <url>/2019/03/17/Java%E6%95%B0%E5%AD%97%E9%87%91%E9%A2%9D%E5%A4%A7%E5%86%99%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/Java%E6%95%B0%E5%AD%97%E9%87%91%E9%A2%9D.jpg" alt=""></p>
<a id="more"></a>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在工作中遇到结算单报表打印的需求，需要展示中文大写金额，为赶时间首先当然是google了(真实情况是觉得自己水平不够，写出来的util会有问题)</p>
<h3 id="最初（来自CSDN，看到的也是转载贴，未注明出处，侵删）"><a href="#最初（来自CSDN，看到的也是转载贴，未注明出处，侵删）" class="headerlink" title="最初（来自CSDN，看到的也是转载贴，未注明出处，侵删）"></a>最初（来自CSDN，看到的也是转载贴，未注明出处，侵删）</h3><p>其实这种工具类网上有很多，但个人感觉这个逻辑更加清晰，所以后面都是在这版的基础是进行修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertNumberToUpper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数字金额大写转换，思想先写个完整的然后将如零拾替换成零 要用到正则表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">digitUppercase</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">        String fraction[] = &#123;<span class="string">"角"</span>, <span class="string">"分"</span>&#125;;</span><br><span class="line">        String digit[] = &#123;<span class="string">"零"</span>, <span class="string">"壹"</span>, <span class="string">"贰"</span>, <span class="string">"叁"</span>, <span class="string">"肆"</span>, <span class="string">"伍"</span>, <span class="string">"陆"</span>, <span class="string">"柒"</span>, <span class="string">"捌"</span>, <span class="string">"玖"</span>&#125;;</span><br><span class="line">        String unit[][] = &#123;&#123;<span class="string">"元"</span>, <span class="string">"万"</span>, <span class="string">"亿"</span>&#125;, &#123;<span class="string">""</span>, <span class="string">"拾"</span>, <span class="string">"佰"</span>, <span class="string">"仟"</span>&#125;&#125;;</span><br><span class="line">        String head = n &lt; <span class="number">0</span> ? <span class="string">"负"</span> : <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 如果是负数取绝对值</span></span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="comment">// 小数部分</span></span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fraction.length; i++) &#123;</span><br><span class="line">            <span class="comment">// Math.floor(a)返回大于或等于参数的最小（最接近负无穷大） double值，并等于数学整数，Math.pow(10, i)10的i次幂</span></span><br><span class="line">            s += (digit[(<span class="keyword">int</span>)(Math.floor(n * Math.pow(<span class="number">10</span>, i + <span class="number">1</span>)) % <span class="number">10</span>)] + fraction[i]).replaceAll(<span class="string">"(零.)+"</span>, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            s = <span class="string">"整"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> integerPart = (<span class="keyword">int</span>)Math.floor(n);</span><br><span class="line">        <span class="comment">// 整数部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unit[<span class="number">0</span>].length &amp;&amp; integerPart &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            String p = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; unit[<span class="number">1</span>].length &amp;&amp; n &gt; <span class="number">0</span>; j++) &#123;</span><br><span class="line">                p = digit[integerPart % <span class="number">10</span>] + unit[<span class="number">1</span>][j] + p;</span><br><span class="line">                integerPart = integerPart / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = p.replaceAll(<span class="string">"(零.)*零$"</span>, <span class="string">""</span>).replaceAll(<span class="string">"^$"</span>, <span class="string">"零"</span>) + unit[<span class="number">0</span>][i] + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head + s.replaceAll(<span class="string">"(零.)*零元"</span>, <span class="string">"元"</span>).replaceFirst(<span class="string">"(零.)+"</span>, <span class="string">""</span>).replaceAll(<span class="string">"(零.)+"</span>, <span class="string">"零"</span>).replaceAll(<span class="string">"^整$"</span>, <span class="string">"零元整"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己测试发现能满足业务需要，所以就直接拿来主义了！</p>
<p>后面自己review时发现原贴下面的一条评论是这样的</p>
<blockquote>
<p>Math.floor(n * 10 * Math.pow(10, i)) % 10)第一个方法里面，是否会因为double*10精度问题进行取整导致数据不正确？ 比如40899.84 * 10的double值408998.39999999….向下取整只会取到3，正好碰到了这个问题</p>
</blockquote>
<p>通过mian方法测试发现确实存在这个问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用System.err与System.out没有区别，只是会用红色字体显示，可以很清晰的看出与日志的区别，强烈建议在测试的时候使用</span></span><br><span class="line">    System.err.println(digitUppercase(<span class="number">40899.84</span>));</span><br><span class="line">&#125;</span><br><span class="line">输出结果:肆万零捌佰玖拾玖元捌角叁分</span><br></pre></td></tr></table></figure>

<p>原因：Java中浮点类型运算会产生精度问题(二进制浮点运算引起)</p>
<p>尝试解决问题，思路是既然只有小数部分有问题就把小数部分截取后转换成整数处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertNumberToUpper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">digitCapital</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">        String fraction[] = &#123;<span class="string">"角"</span>, <span class="string">"分"</span>&#125;;</span><br><span class="line">        String digit[] = &#123;<span class="string">"零"</span>, <span class="string">"壹"</span>, <span class="string">"贰"</span>, <span class="string">"叁"</span>, <span class="string">"肆"</span>, <span class="string">"伍"</span>, <span class="string">"陆"</span>, <span class="string">"柒"</span>, <span class="string">"捌"</span>, <span class="string">"玖"</span>&#125;;</span><br><span class="line">        String unit[][] = &#123;&#123;<span class="string">"元"</span>, <span class="string">"万"</span>, <span class="string">"亿"</span>&#125;, &#123;<span class="string">""</span>, <span class="string">"拾"</span>, <span class="string">"佰"</span>, <span class="string">"仟"</span>&#125;&#125;;</span><br><span class="line">	</span><br><span class="line">        String head = n &lt; <span class="number">0</span> ? <span class="string">"负"</span> : <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 如果是负数取绝对值</span></span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 由于n为double类型，所以整数如100转换后变为100.0</span></span><br><span class="line">        String nStr = n + <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 小数部分，小数点为特殊符号，在分割时需进行转义</span></span><br><span class="line">        String split = nStr.split(<span class="string">"\\."</span>)[<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 如果小数部分只有一位且为0，直接舍弃</span></span><br><span class="line">        <span class="keyword">if</span> (!(split.length() == <span class="number">1</span> &amp;&amp; <span class="string">"0"</span>.equals(split))) &#123;</span><br><span class="line">			<span class="comment">// 只精确到小数点后两位</span></span><br><span class="line">            <span class="keyword">if</span> (split.length() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                split = split.substring(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将小数部分转换为整数</span></span><br><span class="line">            Integer integer = Integer.valueOf(split);</span><br><span class="line">            String p = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; split.length() &amp;&amp; i &lt; fraction.length; i++) &#123;</span><br><span class="line">                p = digit[integer % <span class="number">10</span>] + fraction[split.length() - i - <span class="number">1</span>] + p;</span><br><span class="line">                integer = integer / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = p.replaceAll(<span class="string">"(零.)+"</span>, <span class="string">""</span>) + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            s = <span class="string">"整"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> integerPart = (<span class="keyword">int</span>)Math.floor(n);</span><br><span class="line">        <span class="comment">// 整数部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unit[<span class="number">0</span>].length &amp;&amp; integerPart &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            String p = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; unit[<span class="number">1</span>].length &amp;&amp; n &gt; <span class="number">0</span>; j++) &#123;</span><br><span class="line">                p = digit[integerPart % <span class="number">10</span>] + unit[<span class="number">1</span>][j] + p;</span><br><span class="line">                integerPart = integerPart / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = p.replaceAll(<span class="string">"(零.)*零$"</span>, <span class="string">""</span>).replaceAll(<span class="string">"^$"</span>, <span class="string">"零"</span>) + unit[<span class="number">0</span>][i] + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head + s.replaceAll(<span class="string">"(零.)*零元"</span>, <span class="string">"元"</span>).replaceFirst(<span class="string">"(零.)+"</span>, <span class="string">""</span>).replaceAll(<span class="string">"(零.)+"</span>, <span class="string">"零"</span>).replaceAll(<span class="string">"^整$"</span>, <span class="string">"零元整"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试发现解决了上面的问题</p>
<p>然而又发现新的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.err.println(digitCapital(<span class="number">40800099.84</span>));</span><br><span class="line">&#125;</span><br><span class="line">输出结果:肆仟捌拾万零玖拾玖元捌分</span><br></pre></td></tr></table></figure>

<p>这是因为java中对过大的数据采用科学计数法表示，debug会发现传到方法中的n已经变为<code>4.080009984E7</code></p>
<img src="http://oss.forestyoung.top/Java数字金额(1).png"/>

<p>然后就是解决问题了，思路就是不使用科学计数法表示数据</p>
<p>查资料发现有两种方式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">NumberFormat nf = NumberFormat.getInstance();</span><br><span class="line">nf.setGroupingUsed(<span class="keyword">false</span>);</span><br><span class="line">String nStr = nf.format(n);</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(Double.valueOf(n).toString());</span><br><span class="line">String nStr = bigDecimal.toString();</span><br></pre></td></tr></table></figure>

<p>通过下面简单测试，发现方法二的效率明显要好于方法一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">digitCapital</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    String fraction[] = &#123;<span class="string">"角"</span>, <span class="string">"分"</span>&#125;;</span><br><span class="line">    String digit[] = &#123;<span class="string">"零"</span>, <span class="string">"壹"</span>, <span class="string">"贰"</span>, <span class="string">"叁"</span>, <span class="string">"肆"</span>, <span class="string">"伍"</span>, <span class="string">"陆"</span>, <span class="string">"柒"</span>, <span class="string">"捌"</span>, <span class="string">"玖"</span>&#125;;</span><br><span class="line">    String unit[][] = &#123;&#123;<span class="string">"元"</span>, <span class="string">"万"</span>, <span class="string">"亿"</span>&#125;, &#123;<span class="string">""</span>, <span class="string">"拾"</span>, <span class="string">"佰"</span>, <span class="string">"仟"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    String head = n &lt; <span class="number">0</span> ? <span class="string">"负"</span> : <span class="string">""</span>;</span><br><span class="line">    <span class="comment">// 如果是负数取绝对值</span></span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    String s = <span class="string">""</span>;</span><br><span class="line">    BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(Double.valueOf(n).toString());</span><br><span class="line">    String nStr = bigDecimal.toString();</span><br><span class="line">    <span class="comment">// NumberFormat nf = NumberFormat.getInstance();</span></span><br><span class="line">    <span class="comment">// nf.setGroupingUsed(false);</span></span><br><span class="line">    <span class="comment">// String nStr = nf.format(n);</span></span><br><span class="line">    <span class="comment">// 由于n为double类型，所以整数如100转换后变为100.0</span></span><br><span class="line">    <span class="comment">// 小数部分</span></span><br><span class="line">    String[] split = nStr.split(<span class="string">"\\."</span>);</span><br><span class="line">    <span class="keyword">if</span> (split.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 小数点为特殊符号，在分割时需进行转义</span></span><br><span class="line">        String decimalStr = split[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (decimalStr.length() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            decimalStr = decimalStr.substring(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将小数部分转换为整数</span></span><br><span class="line">        Integer integer = Integer.valueOf(decimalStr);</span><br><span class="line">        String p = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; decimalStr.length() &amp;&amp; i &lt; fraction.length; i++) &#123;</span><br><span class="line">            p = digit[integer % <span class="number">10</span>] + fraction[decimalStr.length() - i - <span class="number">1</span>] + p;</span><br><span class="line">            integer = integer / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = p.replaceAll(<span class="string">"(零.)+"</span>, <span class="string">""</span>) + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        s = <span class="string">"整"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> integerPart = (<span class="keyword">int</span>)Math.floor(n);</span><br><span class="line">    <span class="comment">// 整数部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unit[<span class="number">0</span>].length &amp;&amp; integerPart &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        String p = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; unit[<span class="number">1</span>].length &amp;&amp; n &gt; <span class="number">0</span>; j++) &#123;</span><br><span class="line">            p = digit[integerPart % <span class="number">10</span>] + unit[<span class="number">1</span>][j] + p;</span><br><span class="line">            integerPart = integerPart / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = p.replaceAll(<span class="string">"(零.)*零$"</span>, <span class="string">""</span>).replaceAll(<span class="string">"^$"</span>, <span class="string">"零"</span>) + unit[<span class="number">0</span>][i] + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head + s.replaceAll(<span class="string">"(零.)*零元"</span>, <span class="string">"元"</span>).replaceFirst(<span class="string">"(零.)+"</span>, <span class="string">""</span>).replaceAll(<span class="string">"(零.)+"</span>, <span class="string">"零"</span>).replaceAll(<span class="string">"^整$"</span>, <span class="string">"零元整"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">    System.err.println(digitCapital(<span class="number">1234340899.011231</span>));</span><br><span class="line">    <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">    System.err.println(t2 - t1);</span><br><span class="line">    <span class="keyword">long</span> t3 = System.currentTimeMillis();</span><br><span class="line">    System.err.println(digitCapital(<span class="number">1234340899.011231</span>));</span><br><span class="line">    <span class="keyword">long</span> t4 = System.currentTimeMillis();</span><br><span class="line">    System.err.println(t4 - t3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最终版"><a href="#最终版" class="headerlink" title="最终版"></a>最终版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">digitCapital</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    String fraction[] = &#123;<span class="string">"角"</span>, <span class="string">"分"</span>&#125;;</span><br><span class="line">    String digit[] = &#123;<span class="string">"零"</span>, <span class="string">"壹"</span>, <span class="string">"贰"</span>, <span class="string">"叁"</span>, <span class="string">"肆"</span>, <span class="string">"伍"</span>, <span class="string">"陆"</span>, <span class="string">"柒"</span>, <span class="string">"捌"</span>, <span class="string">"玖"</span>&#125;;</span><br><span class="line">    String unit[][] = &#123;&#123;<span class="string">"元"</span>, <span class="string">"万"</span>, <span class="string">"亿"</span>&#125;, &#123;<span class="string">""</span>, <span class="string">"拾"</span>, <span class="string">"佰"</span>, <span class="string">"仟"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    String head = n &lt; <span class="number">0</span> ? <span class="string">"负"</span> : <span class="string">""</span>;</span><br><span class="line">    <span class="comment">// 如果是负数取绝对值</span></span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    String s = <span class="string">""</span>;</span><br><span class="line">    BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(Double.valueOf(n).toString());</span><br><span class="line">    String nStr = bigDecimal.toString();</span><br><span class="line">    <span class="comment">// 小数部分</span></span><br><span class="line">    String[] split = nStr.split(<span class="string">"\\."</span>);</span><br><span class="line">    <span class="keyword">if</span> (split.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 小数点为特殊符号，在分割时需进行转义</span></span><br><span class="line">        String decimalStr = split[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (decimalStr.length() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            decimalStr = decimalStr.substring(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将小数部分转换为整数</span></span><br><span class="line">        Integer integer = Integer.valueOf(decimalStr);</span><br><span class="line">        String p = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; decimalStr.length() &amp;&amp; i &lt; fraction.length; i++) &#123;</span><br><span class="line">            p = digit[integer % <span class="number">10</span>] + fraction[decimalStr.length() - i - <span class="number">1</span>] + p;</span><br><span class="line">            integer = integer / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = p.replaceAll(<span class="string">"(零.)+"</span>, <span class="string">""</span>) + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        s = <span class="string">"整"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> integerPart = (<span class="keyword">int</span>)Math.floor(n);</span><br><span class="line">    <span class="comment">// 整数部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unit[<span class="number">0</span>].length &amp;&amp; integerPart &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        String p = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; unit[<span class="number">1</span>].length &amp;&amp; n &gt; <span class="number">0</span>; j++) &#123;</span><br><span class="line">            p = digit[integerPart % <span class="number">10</span>] + unit[<span class="number">1</span>][j] + p;</span><br><span class="line">            integerPart = integerPart / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = p.replaceAll(<span class="string">"(零.)*零$"</span>, <span class="string">""</span>).replaceAll(<span class="string">"^$"</span>, <span class="string">"零"</span>) + unit[<span class="number">0</span>][i] + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head + s.replaceAll(<span class="string">"(零.)*零元"</span>, <span class="string">"元"</span>).replaceFirst(<span class="string">"(零.)+"</span>, <span class="string">""</span>).replaceAll(<span class="string">"(零.)+"</span>, <span class="string">"零"</span>).replaceAll(<span class="string">"^整$"</span>, <span class="string">"零元整"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:Integer的取值范围是从-2147483648 至 214748364，超过该范围就会按最大值计算</p>
]]></content>
      <categories>
        <category>代码实现</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL连接异常记录</title>
    <url>/2021/04/02/MySQL%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/freedom-4737919_1920.jpg" alt=""></p>
<a id="more"></a>

<p>应用启动失败，抛出java.sql.SQLException: Access denied for user ‘’@’localhost’ (using password: YES)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;multi_tenant</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line">#spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.name&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;dy123456</span><br></pre></td></tr></table></figure>

<p>发现是数据连接配置错误</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.name</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>应该配置为</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Json反序列化错误</title>
    <url>/2020/09/07/Json%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/woman-5526487_1920.jpg" alt=""></p>
<a id="more"></a>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> Size size;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer length;</span><br><span class="line">        <span class="keyword">private</span> Integer width;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Nmd&gt; nmd;</span><br><span class="line">        <span class="meta">@Data</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nmd</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">         String json = <span class="string">"&#123;\n"</span> +</span><br><span class="line">                <span class="string">"    \"type\": \"bba\",\n"</span> +</span><br><span class="line">                <span class="string">"    \"size\": &#123;\n"</span> +</span><br><span class="line">                <span class="string">"        \"length\": 5,\n"</span> +</span><br><span class="line">                <span class="string">"        \"width\": 3,\n"</span> +</span><br><span class="line">                <span class="string">"        \"nmd\": [\n"</span> +</span><br><span class="line">                <span class="string">"            &#123;\n"</span> +</span><br><span class="line">                <span class="string">"                \"name\": \"123\"\n"</span> +</span><br><span class="line">                <span class="string">"            &#125;\n"</span> +</span><br><span class="line">                <span class="string">"        ]\n"</span> +</span><br><span class="line">                <span class="string">"    &#125;\n"</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        Car car = objectMapper.readValue(json, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行main方法控制台报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of &#96;com.forest.concurrency.Car$Size$Nmd&#96; (although at least one Creator exists): can only instantiate non-static inner class by using default, no-argument constructor</span><br><span class="line"> at [Source: (String)&quot;&#123;</span><br><span class="line">    &quot;type&quot;: &quot;bba&quot;,</span><br><span class="line">    &quot;size&quot;: &#123;</span><br><span class="line">        &quot;length&quot;: 5,</span><br><span class="line">        &quot;width&quot;: 3,</span><br><span class="line">        &quot;nmd&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;123&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&quot;; line: 8, column: 17] (through reference chain: com.forest.concurrency.Car[&quot;size&quot;]-&gt;com.forest.concurrency.Car$Size[&quot;nmd&quot;]-&gt;java.util.ArrayList[0])</span><br></pre></td></tr></table></figure>

<h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><p>参考博客：<a href="https://blog.csdn.net/zhangxiaoyang0/article/details/86022122" target="_blank" rel="noopener">https://blog.csdn.net/zhangxiaoyang0/article/details/86022122</a><br>问题本质为：内部非静态类无法实例化<br>按照博主的解决方法</p>
]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级特性</title>
    <url>/2021/01/24/Python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/aircraft-5336532_1920.jpg" alt=""></p>
<a id="more"></a>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片（Slice）操作符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左包含，右不包含</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个索引为0，可省略</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># L[-1]取倒数第一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:]</span><br><span class="line">[<span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:<span class="number">-1</span>]</span><br><span class="line">[<span class="string">'Bob'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建0~99的数列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = list(range(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只写[:]就可以原样复制一个list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)[:<span class="number">3</span>]</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFG'</span>[:<span class="number">3</span>]</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFG'</span>[::<span class="number">2</span>]</span><br><span class="line"><span class="string">'ACEG'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法：</span></span><br><span class="line"><span class="keyword">while</span> s[:<span class="number">1</span>] == <span class="string">' '</span> <span class="keyword">or</span> s[<span class="number">-1</span>:] == <span class="string">' '</span>:   </span><br><span class="line">   <span class="keyword">if</span> s[:<span class="number">1</span>] == <span class="string">' '</span>:</span><br><span class="line">      s = s[<span class="number">1</span>:]</span><br><span class="line">   <span class="keyword">if</span> s[<span class="number">-1</span>:] == <span class="string">' '</span>:</span><br><span class="line">      s = s[:<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><strong>Python中<code>for</code>循环可以用在所有可迭代对象上</strong></p>
<ul>
<li><p>dict</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="meta">... </span>    print(key)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line"><span class="meta">... </span>    print(value)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时迭代key和value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line">a <span class="number">1</span></span><br><span class="line">b <span class="number">2</span></span><br><span class="line">c <span class="number">3</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>判断对象是否可迭代</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><strong><code>enumerate</code>可以将list变成索引-元素对</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, value)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></table></figure>

<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># for后面加上if判断可以用作筛选元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两层循环，生成全排列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用两个变量生成list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'ibm'</span>, <span class="string">'apple'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># for后面的if是一个筛选条件，不能带else</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">                                              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">6</span>, <span class="number">-7</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else</span></span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul>
<li><p>可用将列表生成式的<code>[]</code>改成<code>()</code> ，就可以创建一个生成器generator</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>next()</code>方法获取generator的下一个返回值，当没有下一个返回值时，抛出<code>StopIteration</code>的错误</p>
</li>
<li><p>使用<code>for</code>循环获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过函数实现generator，使用<code>yield</code>关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>generator和函数执行流程的区别，函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回，generator函数在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句出继续执行。</p>
</li>
<li><p>for循环调用generator时，拿不到return的返回值，需要捕获StopIteration错误，从中获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        x = next(g)</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'g:'</span>, x)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Generator return value:'</span>, e.value)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">2</span></span><br><span class="line">g: <span class="number">3</span></span><br><span class="line">g: <span class="number">5</span></span><br><span class="line">g: <span class="number">8</span></span><br><span class="line">Generator <span class="keyword">return</span> value: done</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote>
<p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p>
<p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p>
<p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p>
<p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">&gt;<span class="keyword">pass</span></span><br><span class="line">&gt;<span class="comment"># 首先获得Iterator对象:</span></span><br><span class="line">&gt;it = iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">&gt;<span class="comment"># 循环:</span></span><br><span class="line">&gt;<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">&gt;<span class="keyword">try</span>:</span><br><span class="line">  <span class="comment"># 获得下一个值:</span></span><br><span class="line">  x = next(it)</span><br><span class="line">&gt;<span class="keyword">except</span> StopIteration:</span><br><span class="line">  <span class="comment"># 遇到StopIteration就退出循环</span></span><br><span class="line">  <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017269809315232" target="_blank" rel="noopener">高级特性</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数</title>
    <url>/2021/01/24/Python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/guitars-2912447_1920.jpg" alt=""></p>
<p>&lt;<a id="more"></a></p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017105451316128" target="_blank" rel="noopener">调用函数</a></h2><h3 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a><a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">Python内置函数</a></h3><ul>
<li><p>可通过help(function)查看函数的帮助信息</p>
</li>
<li><p>调用函数的时候，如果传入的参数数量不对或参数类型不对，会报<code>TypeError</code>的错误</p>
</li>
<li><p>常用函数</p>
<blockquote>
<p>1.abs():求绝对值</p>
<p>2.max():可以接收任意多个参数，并返回最大的那个</p>
<p>3.数据类型转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'123'</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">12.34</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="string">'12.34'</span>)</span><br><span class="line"><span class="number">12.34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">1.23</span>)</span><br><span class="line"><span class="string">'1.23'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">100</span>)</span><br><span class="line"><span class="string">'100'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">''</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = abs <span class="comment"># 变量a指向abs函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017106984190464" target="_blank" rel="noopener">定义函数</a></h2><ul>
<li><p>定义函数使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有<code>return</code>语句，默认返回None，return None可简写为return</p>
</li>
<li><p>空函数可以使用<code>pass</code>语句，实际上<code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。缺少了<code>pass</code>，代码运行就会有语法错误</p>
</li>
<li><p>参数检查，<strong>数据类型检查可以用内置函数<code>isinstance()</code>实现：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回多个值，其实就是一个tuple，Python函数返回的仍然是单一值，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y)</span><br><span class="line"><span class="number">151.96152422706632</span> <span class="number">70.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r)</span><br><span class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p><code>x</code>和<code>n</code>，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数<code>x</code>和<code>n</code>。</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p><strong>使用注意：必选参数在前，默认参数在后，否则Python的解释器会报错</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enroll</span><span class="params">(name, gender, age=<span class="number">6</span>, city=<span class="string">'Beijing'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name)</span><br><span class="line">    print(<span class="string">'gender:'</span>, gender)</span><br><span class="line">    print(<span class="string">'age:'</span>, age)</span><br><span class="line">    print(<span class="string">'city:'</span>, city)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按参数定义顺序调用</span></span><br><span class="line">enroll(<span class="string">'Bob'</span>, <span class="string">'M'</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment"># 不按参数定义顺序调用，需要写上参数名称</span></span><br><span class="line">enroll(<span class="string">'Adam'</span>, <span class="string">'M'</span>, city=<span class="string">'Tianjin'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>])</span><br><span class="line">[<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'END'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多次调用结果不对</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>, <span class="string">'END'</span>]</span><br></pre></td></tr></table></figure>

<p>原因解释如下：</p>
<p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p>
<p> <strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p>
<p>用None这个不变对象可解决上述问题</p>
<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p>
<p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
<h3 id="位置参数-1"><a href="#位置参数-1" class="headerlink" title="位置参数"></a>位置参数</h3><p>我们先写一个计算x2的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure>

<p>对于<code>power(x)</code>函数，参数<code>x</code>就是一个位置参数。</p>
<p>当我们调用<code>power</code>函数时，必须传入有且仅有的一个参数<code>x</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(15)</span><br><span class="line">225</span><br></pre></td></tr></table></figure>

<p>现在，如果我们要计算x3怎么办？可以再定义一个<code>power3</code>函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。</p>
<p>你也许想到了，可以把<code>power(x)</code>修改为<code>power(x, n)</code>，用来计算xn，说干就干：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x, n):</span><br><span class="line">    s &#x3D; 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n &#x3D; n - 1</span><br><span class="line">        s &#x3D; s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>

<p>对于这个修改后的<code>power(x, n)</code>函数，可以计算任意n次方：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 3)</span><br><span class="line">125</span><br></pre></td></tr></table></figure>

<p>修改后的<code>power(x, n)</code>函数有两个参数：<code>x</code>和<code>n</code>，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数<code>x</code>和<code>n</code>。</p>
<h3 id="默认参数-1"><a href="#默认参数-1" class="headerlink" title="默认参数"></a>默认参数</h3><p>新的<code>power(x, n)</code>函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: power() missing 1 required positional argument: &#39;n&#39;</span><br></pre></td></tr></table></figure>

<p>Python的错误信息很明确：调用函数<code>power()</code>缺少了一个位置参数<code>n</code>。</p>
<p>这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x, n&#x3D;2):</span><br><span class="line">    s &#x3D; 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n &#x3D; n - 1</span><br><span class="line">        s &#x3D; s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>

<p>这样，当我们调用<code>power(5)</code>时，相当于调用<code>power(5, 2)</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<p>而对于<code>n &gt; 2</code>的其他情况，就必须明确地传入n，比如<code>power(5, 3)</code>。</p>
<p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：</p>
<p>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</p>
<p>二是如何设置默认参数。</p>
<p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
<p>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p>
<p>举个例子，我们写个一年级小学生注册的函数，需要传入<code>name</code>和<code>gender</code>两个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def enroll(name, gender):</span><br><span class="line">    print(&#39;name:&#39;, name)</span><br><span class="line">    print(&#39;gender:&#39;, gender)</span><br></pre></td></tr></table></figure>

<p>这样，调用<code>enroll()</code>函数只需要传入两个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&#39;Sarah&#39;, &#39;F&#39;)</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br></pre></td></tr></table></figure>

<p>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。</p>
<p>我们可以把年龄和城市设为默认参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def enroll(name, gender, age&#x3D;6, city&#x3D;&#39;Beijing&#39;):</span><br><span class="line">    print(&#39;name:&#39;, name)</span><br><span class="line">    print(&#39;gender:&#39;, gender)</span><br><span class="line">    print(&#39;age:&#39;, age)</span><br><span class="line">    print(&#39;city:&#39;, city)</span><br></pre></td></tr></table></figure>

<p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&#39;Sarah&#39;, &#39;F&#39;)</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br><span class="line">age: 6</span><br><span class="line">city: Beijing</span><br></pre></td></tr></table></figure>

<p>只有与默认参数不符的学生才需要提供额外的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enroll(&#39;Bob&#39;, &#39;M&#39;, 7)</span><br><span class="line">enroll(&#39;Adam&#39;, &#39;M&#39;, city&#x3D;&#39;Tianjin&#39;)</span><br></pre></td></tr></table></figure>

<p>可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p>
<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll(&#39;Bob&#39;, &#39;M&#39;, 7)</code>，意思是，除了<code>name</code>，<code>gender</code>这两个参数外，最后1个参数应用在参数<code>age</code>上，<code>city</code>参数由于没有提供，仍然使用默认值。</p>
<p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)</code>，意思是，<code>city</code>参数用传进去的值，其他默认参数继续使用默认值。</p>
<p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：</p>
<p>先定义一个函数，传入一个list，添加一个<code>END</code>再返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add_end(L&#x3D;[]):</span><br><span class="line">    L.append(&#39;END&#39;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure>

<p>当你正常调用时，结果似乎不错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end([1, 2, 3])</span><br><span class="line">[1, 2, 3, &#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span><br><span class="line">[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;END&#39;]</span><br></pre></td></tr></table></figure>

<p>当你使用默认参数调用时，一开始结果也是对的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br></pre></td></tr></table></figure>

<p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;, &#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;]</span><br></pre></td></tr></table></figure>

<p>很多初学者很疑惑，默认参数是<code>[]</code>，但是函数似乎每次都“记住了”上次添加了<code>&#39;END&#39;</code>后的list。</p>
<p>原因解释如下：</p>
<p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p>
<p> 定义默认参数要牢记一点：默认参数必须指向不变对象！</p>
<p>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 已有list或tuple，调用可变参数函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])</span><br><span class="line"><span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *nums表示把nums这个list的所有元素作为可变参数传进去</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数在函数内部自动组装为一个dict</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Michael'</span>, <span class="number">30</span>)</span><br><span class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可先组装一个dict，当做关键字参数传入函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=extra[<span class="string">'city'</span>], job=extra[<span class="string">'job'</span>])</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>`</strong>extra<code>表示把</code>extra<code>这个dict的所有key-value用关键字参数传入到函数的</code><strong>kw<code>参数，</code>kw<code>将获得一个dict，注意</code>kw<code>获得的dict是</code>extra<code>的一份拷贝，对</code>kw<code>的改动不会影响到函数外的</code>extra`。</strong></p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br></pre></td></tr></table></figure>

<p>命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字函数</p>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure>

<p>命名关键字参数必须传入参数名，未传会报错</p>
<p>注意，使用命名关键字参数时，如果没有可变参数，必须加上<code>*</code>作为特殊分隔符，不然Python解释器将无法识别位置参数和命名关键字参数</p>
<h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>
<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p>
<p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p>
<p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p>
</blockquote>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><blockquote>
<p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p>
<p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p>
<p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1000</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact</span><br><span class="line">  ...</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact</span><br><span class="line">RuntimeError: maximum recursion depth exceeded <span class="keyword">in</span> comparison</span><br></pre></td></tr></table></figure>

<p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<p>上面的<code>fact(n)</code>函数由于<code>return n * fact(n - 1)</code>引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>return fact_iter(num - 1, num * product)</code>仅返回递归函数本身，<code>num - 1</code>和<code>num * product</code>在函数调用前就会被计算，不影响函数调用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017105145133280" target="_blank" rel="noopener">函数</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2021/01/24/Python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/field-5430070_1920.jpg" alt=""></p>
<a id="more"></a>

<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017063826246112" target="_blank" rel="noopener">数据类型和变量</a></h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>整数：</p>
<ul>
<li>Python允许在数字中间以<code>_</code>分隔，<code>10_000_000_000</code>和<code>10000000000</code>是完全一样的</li>
<li><strong>Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的</strong></li>
</ul>
</li>
<li><p>浮点数</p>
<ul>
<li><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（<strong>除法难道也是精确的？是的！</strong>），而浮点数运算则可能会有四舍五入的误差。</p>
</li>
<li><p>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</p>
</li>
<li><p>除法为什么也是精确的</p>
<blockquote>
<p>Python中有两种除法，<code>/</code>和<code>//</code>（地板除）</p>
<p>1.<code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> / <span class="number">3</span></span><br><span class="line"><span class="number">3.3333333333333335</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span> / <span class="number">3</span></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure>

<p>2.<code>//</code>两个整数的除法仍然是整数，整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> // <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>3.<code>//</code>除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> % <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>


</blockquote>
</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li>以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，转义字符<code>\</code></li>
<li>如果字符串里面有很多字符都需要转义，就需要加很多<code>\</code>，为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</li>
<li>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</li>
</ul>
</li>
<li><p>布尔</p>
<ul>
<li><p>布尔值只有<code>True</code>、<code>False</code>两种值，<strong>注意大小写</strong></p>
</li>
<li><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p>
</li>
<li><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">True</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span>
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span> <span class="keyword">and</span> <span class="literal">False</span>
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">1</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">True</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span> <span class="keyword">or</span> <span class="literal">False</span>
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt; <span class="number">3</span> <span class="keyword">or</span> <span class="number">1</span> &gt; <span class="number">3</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="literal">True</span>
<span class="literal">False</span>
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="literal">False</span>
<span class="literal">True</span>
<span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="number">1</span> &gt; <span class="number">2</span>
<span class="literal">True</span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 空值</span><br><span class="line"></span><br><span class="line">  - 用&#96;None&#96;表示</span><br><span class="line"></span><br><span class="line">### 变量</span><br><span class="line"></span><br><span class="line">- 变量不仅可以是数字，还可以是任意数据类型。</span><br><span class="line">- 变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和&#96;_&#96;的组合，且不能用数字开头</span><br><span class="line">- 在Python中，等号&#96;&#x3D;&#96;是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，这种变量本身类型不固定的语言称之为**动态语言**，类比Java是静态语言</span><br><span class="line">- 变量在计算机内存中的表示，例：a &#x3D; &#39;ABC&#39;，Python解释器干了两件事情：</span><br><span class="line">  1. 在内存中创建了一个&#96;&#39;ABC&#39;&#96;的字符串；</span><br><span class="line">  2. 在内存中创建了一个名为&#96;a&#96;的变量，并把它指向&#96;&#39;ABC&#39;&#96;。</span><br><span class="line"></span><br><span class="line">### 常量</span><br><span class="line"></span><br><span class="line">- 在Python中，通常用全部大写的变量名表示常量，例：PI &#x3D; 3.14159265359，ps：但事实上&#96;PI&#96;仍然是一个变量，Python根本没有任何机制保证&#96;PI&#96;不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量&#96;PI&#96;的值，也没人能拦住你</span><br><span class="line"></span><br><span class="line">## [字符串和编码](https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;wiki&#x2F;1016959663602400&#x2F;1017075323632896)</span><br><span class="line"></span><br><span class="line">### 字符编码</span><br><span class="line"></span><br><span class="line">&gt; 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111&#x3D;十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是&#96;65535&#96;，4个字节可以表示的最大整数是&#96;4294967295&#96;。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为&#96;ASCII&#96;编码，比如大写字母&#96;A&#96;的编码是&#96;65&#96;，小写字母&#96;z&#96;的编码是&#96;122&#96;。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了&#96;GB2312&#96;编码，用来把中文编进去。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 你可以想得到的是，全世界有上百种语言，日本把日文编到&#96;Shift_JIS&#96;里，韩国把韩文编到&#96;Euc-kr&#96;里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</span><br><span class="line">&gt;</span><br><span class="line">&gt; Unicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 字母&#96;A&#96;用ASCII编码是十进制的&#96;65&#96;，二进制的&#96;01000001&#96;；</span><br><span class="line">&gt;</span><br><span class="line">&gt; 字符&#96;0&#96;用ASCII编码是十进制的&#96;48&#96;，二进制的&#96;00110000&#96;，注意字符&#96;&#39;0&#39;&#96;和整数&#96;0&#96;是不同的；</span><br><span class="line">&gt;</span><br><span class="line">&gt; 汉字&#96;中&#96;已经超出了ASCII编码的范围，用Unicode编码是十进制的&#96;20013&#96;，二进制的&#96;01001110 00101101&#96;。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 你可以猜测，如果把ASCII编码的&#96;A&#96;用Unicode编码，只需要在前面补0就可以，因此，&#96;A&#96;的Unicode编码是&#96;00000000 01000001&#96;。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的&#96;UTF-8&#96;编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</span><br><span class="line">&gt;</span><br><span class="line">&gt; | 字符 | ASCII    | Unicode           | UTF-8                      |</span><br><span class="line">&gt; | :--- | :------- | :---------------- | :------------------------- |</span><br><span class="line">&gt; | A    | 01000001 | 00000000 01000001 | 01000001                   |</span><br><span class="line">&gt; | 中   | x        | 01001110 00101101 | 11100100 10111000 10101101 |</span><br><span class="line">&gt;</span><br><span class="line">&gt; 从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</span><br><span class="line">&gt;</span><br><span class="line">&gt; 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</span><br><span class="line"></span><br><span class="line">### Python的字符串</span><br><span class="line"></span><br><span class="line">- 在Python 3版本中，字符串以Unicode编码。</span><br><span class="line"></span><br><span class="line">- &#96;ord()&#96;函数获取字符的整数表示，&#96;chr()&#96;函数把编码转换为对应的字符。</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;python</span><br><span class="line">  &gt;&gt;&gt; ord(&#39;A&#39;)</span><br><span class="line">  65</span><br><span class="line">  &gt;&gt;&gt; ord(&#39;中&#39;)</span><br><span class="line">  20013</span><br><span class="line">  &gt;&gt;&gt; chr(66)</span><br><span class="line">  &#39;B&#39;</span><br><span class="line">  &gt;&gt;&gt; chr(25991)</span><br><span class="line">  &#39;文&#39;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号，例：x = b’ABC’</p>
</li>
<li><p><code>encode()</code>和<code>decode()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode characters in position 0-1: ordinal not in range(128)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b'</span>ABC<span class="string">'.decode('</span>ascii<span class="string">')</span></span><br><span class="line"><span class="string">'</span>ABC<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b'</span>\xe4\xb8\xad\xe6\x96\x87<span class="string">'.decode('</span>utf<span class="number">-8</span><span class="string">')</span></span><br><span class="line"><span class="string">'</span>中文<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b'</span>\xe4\xb8\xad\xf<span class="string">f'.decode('</span>utf<span class="number">-8</span><span class="string">')</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">UnicodeDecodeError: '</span>utf<span class="number">-8</span><span class="string">' codec can'</span>t decode byte <span class="number">0xff</span> <span class="keyword">in</span> position <span class="number">3</span>: invalid start byte</span><br><span class="line">  &gt;&gt;&gt; <span class="string">b'\xe4\xb8\xad\xff'</span>.decode(<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line"><span class="string">'中'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算字符串包含多少个字符，用<code>len()</code>函数，如果是bytes，计算的是字节数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在操作字符串时，我们经常遇到<code>str</code>和<code>bytes</code>的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。</strong></p>
</li>
</ul>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul>
<li>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现</li>
</ul>
<blockquote>
<p>常见的占位符有：</p>
<table>
<thead>
<tr>
<th align="left">占位符</th>
<th align="left">替换内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%d</td>
<td align="left">整数</td>
</tr>
<tr>
<td align="left">%f</td>
<td align="left">浮点数</td>
</tr>
<tr>
<td align="left">%s</td>
<td align="left">字符串</td>
</tr>
<tr>
<td align="left">%x</td>
<td align="left">十六进制整数</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li><h3 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h3></li>
<li><h3 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h3></li>
</ul>
<h3 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017092876846880" target="_blank" rel="noopener">list和tuple</a></h3><blockquote>
<p><strong>list和tuple是Python内置的有序集合，一个可变，一个不可变</strong></p>
</blockquote>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul>
<li>len()获取元素个数</li>
<li>索引从0开始，超出范围会报<code>IndexError</code>错误，可通过list[-1]获取最后一个元素，以此类推，同样需要注意越界问题</li>
<li>append()追加元素到末尾</li>
<li>insert(1, “”)可以插入元素到指定位置</li>
<li>pop()删除list末尾的元素，pop(i)删除指定位置的元素</li>
<li>list中的元素数据类型可以不同，类似Java中的Object List</li>
<li>list元素也可以是另一个list，例：s = [‘python’, ‘java’, [‘asp’, ‘php’], ‘scheme’]，’php’<code>可以写</code>p[1]<code>或者</code>s[2] [1]，可以看成二维数组</li>
</ul>
<h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><ul>
<li><p>初始化后不能修改，无append()、insert()方法，获取元素的方法与list一样</p>
</li>
<li><p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p>
</li>
<li><p>定义一个tuple时，tuple的元素必须确定下来，注意：只有一个元素时必须加上逗号与数学公式中的小括号区分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 空的tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">()</span><br><span class="line"><span class="comment"># 这里定义的不是tuple，表示的是1这个数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 正确的定义方式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure>
</li>
<li><p>tuple的不变指的是“指向不变”，例：tuple中包含list，list的指向是可变的</p>
</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017099478626848" target="_blank" rel="noopener">条件判断</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'your age is'</span>, age)</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line">    </span><br><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'your age is'</span>, age)</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'your age is'</span>, age)</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line">    </span><br><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017100774566304" target="_blank" rel="noopener">循环</a></h3><h4 id="两种循环"><a href="#两种循环" class="headerlink" title="两种循环"></a>两种循环</h4><ul>
<li><p>for…in</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]:</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br><span class="line">range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(<span class="number">5</span>)生成的序列是从<span class="number">0</span>开始小于<span class="number">5</span>的整数</span><br></pre></td></tr></table></figure>
</li>
<li><p>while</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用enumerate()函数可以获得元素下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> inx, val <span class="keyword">in</span> enumerate([<span class="string">'uyy'</span>, <span class="string">'dfdf'</span>]):</span><br><span class="line">	    print(inx)</span><br><span class="line">	    print(val)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h4><ul>
<li>break退出当前循环</li>
<li>continue跳过本次循环，进入下次循环</li>
</ul>
<h4 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017104324028448" target="_blank" rel="noopener">使用dict和set</a></h4><h4 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h4><ul>
<li><p>不可变对象，如字符串、整数，可变对象，如list</p>
</li>
<li><p>a是变量，’abc’是字符串对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="string">'Abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'abc'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对不可变对象调用自身的任意方法，不会改变对象本身，只是这些方法会创建新的对象并返回，这样保证了不可变对象本身永远是不可变的</p>
</li>
</ul>
<h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</span><br><span class="line"><span class="number">95</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>] = <span class="number">67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>]</span><br><span class="line"><span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>] = <span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>]</span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>] = <span class="number">88</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>]</span><br><span class="line"><span class="number">88</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Thomas'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'Thomas'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>dict的key必须是不可变对象</strong>，dict是根据key计算value的存储位置，如果相同的key计算出不同的结果，dict内部就完全混乱了</p>
</li>
<li><p>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
</li>
<li><p><code>in</code>可判断key是否存在</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pop(key)</code>删除对应的key和value</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul>
<li><p>set和dict的原理一样，区别在于set没有存储对应的value</p>
</li>
<li><p>要创建一个set，需要提供一个list作为输入集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>set中key不能重复，重复元素在set中自动被过滤</p>
</li>
<li><p><code>add(key)</code>方法将元素添加到set中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>remove(key)</code>方法可以删除元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="tuple放入dict和set中"><a href="#tuple放入dict和set中" class="headerlink" title="tuple放入dict和set中"></a>tuple放入dict和set中</h4><p><strong>tuple虽然是不变对象，但试试把<code>(1, 2, 3)</code>和<code>(1, [2, 3])</code>放入dict或set中，并解释结果。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tuple放入dict：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[t]=<span class="number">63</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">63</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>]=t</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">63</span>, <span class="number">1</span>: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[t]=<span class="number">32</span></span><br><span class="line">Traceback (most recent call last):  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; TypeError: unhashable type: <span class="string">'list'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>]=t</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">63</span>, <span class="number">1</span>: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="number">2</span>: (<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>])&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#tuple放入set：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(t)</span><br><span class="line">Traceback (most recent call last):  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; TypeError: unhashable type: <span class="string">'list'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>分别把“可变”tuple（含list的tuple）和不可变的tuple放入dict的key和value：</p>
<p>“可变tuple”放入dict的key显示非法hash的key；不可变tapule正常放入。</p>
</li>
<li><p>把“可变tuple”（含list的tuple）和不可变tuple放入set：</p>
<p>“可变tuple”不可放入set（无法判断是否和已有元素相同）；不可变tuple放入set正常。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>要理解dict的有关内容需要你理解哈希表（map）的相关基础知识，这个其实是《算法与数据结构》里面的内容。</p>
<p>1.list和tuple其实是用链表顺序存储的，也就是前一个元素中存储了下一个元素的位置，这样只要找到第一个元素的位置就可以顺藤摸瓜找到所有元素的位置，所以list的名字其实就是个指针，指向list的第一个元素的位置。list的插入和删除等可以直接用链表的方式进行，比如我要在第1个元素和第2个元素中间插入一个元素，那么直接在链表的最后面（我们假设这个list只有两个元素，那么也就是在第3个元素的位置上）插入这个元素，然后把第一个元素指针指向这个元素（第3个位置），然后再把新插入的元素的指针指向原来的第2个元素，这样插入操作就完成了。读取这个list的时候，先用list的名字（就是个指针，指向第1个元素的位置）找到第一个元素，然后用第1一个元素的指针找到第2个元素（位置3），然后用第2个元素的指针找到第3个元素（位置2），以此类推。所以list的顺序和内存中的实际顺序其实不一定完全对应。这种存储方式不会浪费内存，但查找起来特别费时间，因为要按照链表一个一个找下去，如果你的list特别大的话，那么要等好久才会找到结果。</p>
<p>2.dict则为了快速查找使用了一种特别的方法，哈希表。哈希表采用哈希函数从key计算得到一个数字（哈希函数有个特点：对于不同的key，有很大的概率得到的哈希值也不同），然后直接把value存储到这个数字所对应的地址上，比如key=’ABC’，value=10，经过哈希函数得到key对应的哈希值为123，那么就申请一个有1000个地址（从0到999）的内存，然后把10存放在地址为123的地方。类似的，对于key=’BCD’，value=20，得到key的哈希值为234，那么就把20存放在地址为234的地方。对于这样的表查找起来是非常方便的。只要给出key，计算得到哈希值，然后直接到对应的地址去找value就可以了。无论有几个元素，都可以直接找到value，无需遍历整个表。不过虽然dict查找速度快，但内存浪费严重，你看我们只存储了两个元素，都要申请一个长度为1000的内存。</p>
<p>3.现在你知道为啥key要用不可变对象了吧？因为不可变对象是常量，每次的哈希值算出来都是固定的，这样就不会出错。比如key=’ABC’，value=10，存储地址为123，假设我突发奇想，把key改成’BCD’，那么当查找’BCD’的value的时候就会去234的地址找，但那里啥也没有，这就乱套了。</p>
<p>4.你看我们上面有一句话：对于不同的key，有很大的概率得到的哈希值也不同。那么有很小的概率不同的key可以得到相同的哈希值了？没错，比如对于我们的例子来说，哈希值只有3位，那么只要元素个数超过1000，就一定会有至少两个key的哈希值相同（鸽笼原理），这种情况叫“冲突”，设计哈希表的时候要采取办法减少冲突，实在冲突了也要想办法补救。不过这是编译器的事情，况且对于初学者的我们来说碰到的冲突的概率基本等于零，就不用操心了。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832" target="_blank" rel="noopener">Python基础</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2021/01/24/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/sunset-5801050_1920.jpg" alt=""></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init   &#x2F;&#x2F;初始化</span><br><span class="line"></span><br><span class="line">hexo new &quot;page name&quot;  &#x2F;&#x2F; 新建page</span><br><span class="line">hexo clean  &#x2F;&#x2F; 清除本地缓存</span><br><span class="line">hexo g     &#x2F;&#x2F; 生成页面</span><br><span class="line">hexo s     &#x2F;&#x2F; 启动服务，本地预览</span><br><span class="line">hexo d     &#x2F;&#x2F; 部署</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>http状态码</title>
    <url>/2019/02/13/http%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/http%E7%8A%B6%E6%80%81%E7%A0%81.jpg" alt=""></p>
<a id="more"></a>

<p>100——客户必须继续发出请求</p>
<p>101——客户要求服务器根据请求转换HTTP协议版本</p>
<p>200——交易成功</p>
<p>201——提示知道新文件的URL</p>
<p>202——接受和处理、但处理未完成</p>
<p>203——返回信息不确定或不完整</p>
<p>204——请求收到，但返回信息为空</p>
<p>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</p>
<p>206——服务器已经完成了部分用户的GET请求</p>
<p>300——请求的资源可在多处得到</p>
<p>301——删除请求数据</p>
<p>302——在其他地址发现了请求数据</p>
<p>303——建议客户访问其他URL或访问方式</p>
<p>304——客户端已经执行了GET，但文件未变化</p>
<p>305——请求的资源必须从服务器指定的地址得到</p>
<p>306——前一版本HTTP中使用的代码，现行版本中不再使用</p>
<p>307——申明请求的资源临时性删除</p>
<p>400——错误请求，如语法错误</p>
<p>401——请求授权失败</p>
<p>402——保留有效ChargeTo头响应</p>
<p>403——请求不允许</p>
<p>404——没有发现文件、查询或URl</p>
<p>405——用户在Request-Line字段定义的方法不允许</p>
<p>406——根据用户发送的Accept拖，请求资源不可访问</p>
<p>407——类似401，用户必须首先在代理服务器上得到授权</p>
<p>408——客户端没有在用户指定的时间内完成请求</p>
<p>409——对当前资源状态，请求不能完成</p>
<p>410——服务器上不再有此资源且无进一步的参考地址</p>
<p>411——服务器拒绝用户定义的Content-Length属性请求</p>
<p>412——一个或多个请求头字段在当前请求中错误</p>
<p>413——请求的资源大于服务器允许的大小</p>
<p>414——请求的资源URL长于服务器允许的长度</p>
<p>415——请求资源不支持请求项目格式</p>
<p>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</p>
<p>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</p>
<p>500——服务器产生内部错误</p>
<p>501——服务器不支持请求的函数</p>
<p>502——服务器暂时不可用，有时是为了防止发生系统过载</p>
<p>503——服务器过载或暂停维修</p>
<p>504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</p>
<p>505——服务器不支持或拒绝支请求头中指定的HTTP版本</p>
]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cache使用</title>
    <url>/2020/09/08/Spring%20Cache%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/huangpu-river-5501210_1920.jpg" alt=""></p>
<a id="more"></a>

<h3 id="相关依赖"><a href="#相关依赖" class="headerlink" title="相关依赖"></a>相关依赖</h3><p>在 Spring 3.1 中引入了多 Cache 的支持，在 spring-context 包中已包含，所以只用引入spring-context包即可</p>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><p>需要在启动类加上<strong>@EnableCaching</strong>注解</p>
<p>被缓存对象需要实现Serializable接口</p>
<h3 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h3><p><a href="https://juejin.im/post/6844903966615011335" target="_blank" rel="noopener">Spring Boot 2.X(七)：Spring Cache 使用</a></p>
<p><a href="https://www.cnblogs.com/fashflying/p/6908028.html" target="_blank" rel="noopener">Spring缓存注解@Cacheable、@CacheEvict、@CachePut使用</a></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码学习（一）：BeanFactory</title>
    <url>/2021/04/02/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ABeanFactory/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/leaves-5610361_1920.png" alt=""></p>
<a id="more"></a>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>为保证准确性，这里直接复制源码，使用的Spring版本为5.2.6.BUILD-SNAPSHOT</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2020 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ResolvableType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The root interface for accessing a Spring bean container.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is the basic client view of a bean container;</span></span><br><span class="line"><span class="comment"> * further interfaces such as &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.ConfigurableBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * are available for specific purposes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is implemented by objects that hold a number of bean definitions,</span></span><br><span class="line"><span class="comment"> * each uniquely identified by a String name. Depending on the bean definition,</span></span><br><span class="line"><span class="comment"> * the factory will return either an independent instance of a contained object</span></span><br><span class="line"><span class="comment"> * (the Prototype design pattern), or a single shared instance (a superior</span></span><br><span class="line"><span class="comment"> * alternative to the Singleton design pattern, in which the instance is a</span></span><br><span class="line"><span class="comment"> * singleton in the scope of the factory). Which type of instance will be returned</span></span><br><span class="line"><span class="comment"> * depends on the bean factory configuration: the API is the same. Since Spring</span></span><br><span class="line"><span class="comment"> * 2.0, further scopes are available depending on the concrete application</span></span><br><span class="line"><span class="comment"> * context (e.g. "request" and "session" scopes in a web environment).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The point of this approach is that the BeanFactory is a central registry</span></span><br><span class="line"><span class="comment"> * of application components, and centralizes configuration of application</span></span><br><span class="line"><span class="comment"> * components (no more do individual objects need to read properties files,</span></span><br><span class="line"><span class="comment"> * for example). See chapters 4 and 11 of "Expert One-on-One J2EE Design and</span></span><br><span class="line"><span class="comment"> * Development" for a discussion of the benefits of this approach.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that it is generally better to rely on Dependency Injection</span></span><br><span class="line"><span class="comment"> * ("push" configuration) to configure application objects through setters</span></span><br><span class="line"><span class="comment"> * or constructors, rather than use any form of "pull" configuration like a</span></span><br><span class="line"><span class="comment"> * BeanFactory lookup. Spring's Dependency Injection functionality is</span></span><br><span class="line"><span class="comment"> * implemented using this BeanFactory interface and its subinterfaces.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Normally a BeanFactory will load bean definitions stored in a configuration</span></span><br><span class="line"><span class="comment"> * source (such as an XML document), and use the &#123;<span class="doctag">@code</span> org.springframework.beans&#125;</span></span><br><span class="line"><span class="comment"> * package to configure the beans. However, an implementation could simply return</span></span><br><span class="line"><span class="comment"> * Java objects it creates as necessary directly in Java code. There are no</span></span><br><span class="line"><span class="comment"> * constraints on how the definitions could be stored: LDAP, RDBMS, XML,</span></span><br><span class="line"><span class="comment"> * properties file, etc. Implementations are encouraged to support references</span></span><br><span class="line"><span class="comment"> * amongst beans (Dependency Injection).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In contrast to the methods in &#123;<span class="doctag">@link</span> ListableBeanFactory&#125;, all of the</span></span><br><span class="line"><span class="comment"> * operations in this interface will also check parent factories if this is a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> HierarchicalBeanFactory&#125;. If a bean is not found in this factory instance,</span></span><br><span class="line"><span class="comment"> * the immediate parent factory will be asked. Beans in this factory instance</span></span><br><span class="line"><span class="comment"> * are supposed to override beans of the same name in any parent factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces</span></span><br><span class="line"><span class="comment"> * as far as possible. The full set of initialization methods and their standard order is:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanNameAware's &#123;<span class="doctag">@code</span> setBeanName&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanClassLoaderAware's &#123;<span class="doctag">@code</span> setBeanClassLoader&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanFactoryAware's &#123;<span class="doctag">@code</span> setBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EnvironmentAware's &#123;<span class="doctag">@code</span> setEnvironment&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EmbeddedValueResolverAware's &#123;<span class="doctag">@code</span> setEmbeddedValueResolver&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ResourceLoaderAware's &#123;<span class="doctag">@code</span> setResourceLoader&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationEventPublisherAware's &#123;<span class="doctag">@code</span> setApplicationEventPublisher&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;MessageSourceAware's &#123;<span class="doctag">@code</span> setMessageSource&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationContextAware's &#123;<span class="doctag">@code</span> setApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ServletContextAware's &#123;<span class="doctag">@code</span> setServletContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in a web application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom init-method definition</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessAfterInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;DisposableBean's &#123;<span class="doctag">@code</span> destroy&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom destroy-method definition</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 13 April 2001</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanNameAware#setBeanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanClassLoaderAware#setBeanClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanFactoryAware#setBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ResourceLoaderAware#setResourceLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.MessageSourceAware#setMessageSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationContextAware#setApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.ServletContextAware#setServletContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DisposableBean#destroy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Used to dereference a &#123;<span class="doctag">@link</span> FactoryBean&#125; instance and distinguish it from</span></span><br><span class="line"><span class="comment">	 * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> myJndiObject&#125; is a FactoryBean, getting &#123;<span class="doctag">@code</span> &amp;myJndiObject&#125;</span></span><br><span class="line"><span class="comment">	 * will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method allows a Spring BeanFactory to be used as a replacement for the</span></span><br><span class="line"><span class="comment">	 * Singleton or Prototype design pattern. Callers may retain references to</span></span><br><span class="line"><span class="comment">	 * returned objects in the case of Singleton beans.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the specified name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be obtained</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Behaves the same as &#123;<span class="doctag">@link</span> #getBean(String)&#125;, but provides a measure of type</span></span><br><span class="line"><span class="comment">	 * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the</span></span><br><span class="line"><span class="comment">	 * required type. This means that ClassCastException can't be thrown on casting</span></span><br><span class="line"><span class="comment">	 * the result correctly, as can happen with &#123;<span class="doctag">@link</span> #getBean(String)&#125;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanNotOfRequiredTypeException if the bean is not of the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">	 * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">	 * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">	 * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the bean instance that uniquely matches the given object type, if any.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">	 * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">	 * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">	 * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the single bean matching the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if no bean of the given type was found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoUniqueBeanDefinitionException if more than one bean of the given type was found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ListableBeanFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">	 * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">	 * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">	 * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">	 * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">	 * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">	 * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return a provider for the specified bean, allowing for lazy on-demand retrieval</span></span><br><span class="line"><span class="comment">	 * of instances, including availability and uniqueness options.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a corresponding provider handle</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBeanProvider(ResolvableType)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return a provider for the specified bean, allowing for lazy on-demand retrieval</span></span><br><span class="line"><span class="comment">	 * of instances, including availability and uniqueness options.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be a generic type declaration.</span></span><br><span class="line"><span class="comment">	 * Note that collection types are not supported here, in contrast to reflective</span></span><br><span class="line"><span class="comment">	 * injection points. For programmatically retrieving a list of beans matching a</span></span><br><span class="line"><span class="comment">	 * specific type, specify the actual bean type as an argument here and subsequently</span></span><br><span class="line"><span class="comment">	 * use &#123;<span class="doctag">@link</span> ObjectProvider#orderedStream()&#125; or its lazy streaming/iteration options.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a corresponding provider handle</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ObjectProvider#iterator()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ObjectProvider#stream()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ObjectProvider#orderedStream()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Does this bean factory contain a bean definition or externally registered singleton</span></span><br><span class="line"><span class="comment">	 * instance with the given name?</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If the given name is an alias, it will be translated back to the corresponding</span></span><br><span class="line"><span class="comment">	 * canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If this factory is hierarchical, will ask any parent factory if the bean cannot</span></span><br><span class="line"><span class="comment">	 * be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If a bean definition or singleton instance matching the given name is found,</span></span><br><span class="line"><span class="comment">	 * this method will return &#123;<span class="doctag">@code</span> true&#125; whether the named bean definition is concrete</span></span><br><span class="line"><span class="comment">	 * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">	 * return value from this method does not necessarily indicate that &#123;<span class="doctag">@link</span> #getBean&#125;</span></span><br><span class="line"><span class="comment">	 * will be able to obtain an instance for the same name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether a bean with the given name is present</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Is this bean a shared singleton? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always</span></span><br><span class="line"><span class="comment">	 * return the same instance?</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">	 * independent instances. It indicates non-singleton instances, which may correspond</span></span><br><span class="line"><span class="comment">	 * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isPrototype&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">	 * check for independent instances.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether this bean corresponds to a singleton instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isPrototype</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Is this bean a prototype? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always return</span></span><br><span class="line"><span class="comment">	 * independent instances?</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">	 * a singleton object. It indicates non-independent instances, which may correspond</span></span><br><span class="line"><span class="comment">	 * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isSingleton&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">	 * check for a shared singleton instance.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether this bean will always deliver independent instances</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.0.3</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isSingleton</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">	 * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">	 * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> ResolvableType&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">	 * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">	 * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the type of the bean with the given name. More specifically,</span></span><br><span class="line"><span class="comment">	 * determine the type of object that &#123;<span class="doctag">@link</span> #getBean&#125; would return for the given name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;For a &#123;<span class="doctag">@link</span> FactoryBean&#125;, return the type of object that the FactoryBean creates,</span></span><br><span class="line"><span class="comment">	 * as exposed by &#123;<span class="doctag">@link</span> FactoryBean#getObjectType()&#125;. This may lead to the initialization</span></span><br><span class="line"><span class="comment">	 * of a previously uninitialized &#123;<span class="doctag">@code</span> FactoryBean&#125; (see &#123;<span class="doctag">@link</span> #getType(String, boolean)&#125;).</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the type of the bean, or &#123;<span class="doctag">@code</span> null&#125; if not determinable</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isTypeMatch</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the type of the bean with the given name. More specifically,</span></span><br><span class="line"><span class="comment">	 * determine the type of object that &#123;<span class="doctag">@link</span> #getBean&#125; would return for the given name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;For a &#123;<span class="doctag">@link</span> FactoryBean&#125;, return the type of object that the FactoryBean creates,</span></span><br><span class="line"><span class="comment">	 * as exposed by &#123;<span class="doctag">@link</span> FactoryBean#getObjectType()&#125;. Depending on the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> allowFactoryBeanInit&#125; flag, this may lead to the initialization of a previously</span></span><br><span class="line"><span class="comment">	 * uninitialized &#123;<span class="doctag">@code</span> FactoryBean&#125; if no early type information is available.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> allowFactoryBeanInit whether a &#123;<span class="doctag">@code</span> FactoryBean&#125; may get initialized</span></span><br><span class="line"><span class="comment">	 * just for the purpose of determining its object type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the type of the bean, or &#123;<span class="doctag">@code</span> null&#125; if not determinable</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isTypeMatch</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name, <span class="keyword">boolean</span> allowFactoryBeanInit) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the aliases for the given bean name, if any.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;All of those aliases point to the same bean when used in a &#123;<span class="doctag">@link</span> #getBean&#125; call.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If the given name is an alias, the corresponding original bean name</span></span><br><span class="line"><span class="comment">	 * and other aliases (if any) will be returned, with the original bean name</span></span><br><span class="line"><span class="comment">	 * being the first element in the array.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the bean name to check for aliases</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the aliases, or an empty array if none</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactory是一个接口，位于spring-beans包下，定义了最基本的IoC容器功能</p>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>BeanFactory只是定义了IoC容器的基本功能，但并未进行具体实现<br>首先我们对相关注释进行简单粗暴的翻译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method allows a Spring BeanFactory to be used as a replacement for the</span></span><br><span class="line"><span class="comment">	 * Singleton or Prototype design pattern. Callers may retain references to</span></span><br><span class="line"><span class="comment">	 * returned objects in the case of Singleton beans.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the specified name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be obtained</span></span><br><span class="line"><span class="comment">	 * 通过名称获取bean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Behaves the same as &#123;<span class="doctag">@link</span> #getBean(String)&#125;, but provides a measure of type</span></span><br><span class="line"><span class="comment">	 * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the</span></span><br><span class="line"><span class="comment">	 * required type. This means that ClassCastException can't be thrown on casting</span></span><br><span class="line"><span class="comment">	 * the result correctly, as can happen with &#123;<span class="doctag">@link</span> #getBean(String)&#125;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanNotOfRequiredTypeException if the bean is not of the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * 通过名称获取bean，并且指定bean的类型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">	 * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">	 * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">	 * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">	 * 通过名称获取bean，args:使用显式参数创建bean实例时要使用的参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the bean instance that uniquely matches the given object type, if any.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">	 * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">	 * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">	 * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the single bean matching the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if no bean of the given type was found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoUniqueBeanDefinitionException if more than one bean of the given type was found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ListableBeanFactory</span></span><br><span class="line"><span class="comment">	 * 返回唯一匹配给定对象类型（如果有的话）的bean实例。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">	 * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">	 * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">	 * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">	 * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">	 * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">	 * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">	 * 返回指定bean的实例,args:使用显式参数创建bean实例时要使用的参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return a provider for the specified bean, allowing for lazy on-demand retrieval</span></span><br><span class="line"><span class="comment">	 * of instances, including availability and uniqueness options.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a corresponding provider handle</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBeanProvider(ResolvableType)</span></span><br><span class="line"><span class="comment">	 * 返回指定bean的提供者</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return a provider for the specified bean, allowing for lazy on-demand retrieval</span></span><br><span class="line"><span class="comment">	 * of instances, including availability and uniqueness options.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType type the bean must match; can be a generic type declaration.</span></span><br><span class="line"><span class="comment">	 * Note that collection types are not supported here, in contrast to reflective</span></span><br><span class="line"><span class="comment">	 * injection points. For programmatically retrieving a list of beans matching a</span></span><br><span class="line"><span class="comment">	 * specific type, specify the actual bean type as an argument here and subsequently</span></span><br><span class="line"><span class="comment">	 * use &#123;<span class="doctag">@link</span> ObjectProvider#orderedStream()&#125; or its lazy streaming/iteration options.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a corresponding provider handle</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ObjectProvider#iterator()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ObjectProvider#stream()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ObjectProvider#orderedStream()</span></span><br><span class="line"><span class="comment">	 * 返回指定bean的提供者，与上个方法的差别在于，这里的参数可以是泛型类型声明。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Does this bean factory contain a bean definition or externally registered singleton</span></span><br><span class="line"><span class="comment">	 * instance with the given name?</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If the given name is an alias, it will be translated back to the corresponding</span></span><br><span class="line"><span class="comment">	 * canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If this factory is hierarchical, will ask any parent factory if the bean cannot</span></span><br><span class="line"><span class="comment">	 * be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If a bean definition or singleton instance matching the given name is found,</span></span><br><span class="line"><span class="comment">	 * this method will return &#123;<span class="doctag">@code</span> true&#125; whether the named bean definition is concrete</span></span><br><span class="line"><span class="comment">	 * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">	 * return value from this method does not necessarily indicate that &#123;<span class="doctag">@link</span> #getBean&#125;</span></span><br><span class="line"><span class="comment">	 * will be able to obtain an instance for the same name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether a bean with the given name is present</span></span><br><span class="line"><span class="comment">	 * Bean工厂是否包含指定名称的bean实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Is this bean a shared singleton? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always</span></span><br><span class="line"><span class="comment">	 * return the same instance?</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">	 * independent instances. It indicates non-singleton instances, which may correspond</span></span><br><span class="line"><span class="comment">	 * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isPrototype&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">	 * check for independent instances.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether this bean corresponds to a singleton instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isPrototype</span></span><br><span class="line"><span class="comment">	 * 返回给定名称的bean是否是单例的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Is this bean a prototype? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always return</span></span><br><span class="line"><span class="comment">	 * independent instances?</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">	 * a singleton object. It indicates non-independent instances, which may correspond</span></span><br><span class="line"><span class="comment">	 * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isSingleton&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">	 * check for a shared singleton instance.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether this bean will always deliver independent instances</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.0.3</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isSingleton</span></span><br><span class="line"><span class="comment">	 * 返回给定名称的bean是否是多例的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">	 * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">	 * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> ResolvableType&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">	 * 校验给定名称的bean是否和指定类型匹配</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">	 * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">	 * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">	 * 校验给定名称的bean是否和指定类型匹配</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the type of the bean with the given name. More specifically,</span></span><br><span class="line"><span class="comment">	 * determine the type of object that &#123;<span class="doctag">@link</span> #getBean&#125; would return for the given name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;For a &#123;<span class="doctag">@link</span> FactoryBean&#125;, return the type of object that the FactoryBean creates,</span></span><br><span class="line"><span class="comment">	 * as exposed by &#123;<span class="doctag">@link</span> FactoryBean#getObjectType()&#125;. This may lead to the initialization</span></span><br><span class="line"><span class="comment">	 * of a previously uninitialized &#123;<span class="doctag">@code</span> FactoryBean&#125; (see &#123;<span class="doctag">@link</span> #getType(String, boolean)&#125;).</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the type of the bean, or &#123;<span class="doctag">@code</span> null&#125; if not determinable</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isTypeMatch</span></span><br><span class="line"><span class="comment">	 * 返回给定名称bean的类型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the type of the bean with the given name. More specifically,</span></span><br><span class="line"><span class="comment">	 * determine the type of object that &#123;<span class="doctag">@link</span> #getBean&#125; would return for the given name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;For a &#123;<span class="doctag">@link</span> FactoryBean&#125;, return the type of object that the FactoryBean creates,</span></span><br><span class="line"><span class="comment">	 * as exposed by &#123;<span class="doctag">@link</span> FactoryBean#getObjectType()&#125;. Depending on the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> allowFactoryBeanInit&#125; flag, this may lead to the initialization of a previously</span></span><br><span class="line"><span class="comment">	 * uninitialized &#123;<span class="doctag">@code</span> FactoryBean&#125; if no early type information is available.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> allowFactoryBeanInit whether a &#123;<span class="doctag">@code</span> FactoryBean&#125; may get initialized</span></span><br><span class="line"><span class="comment">	 * just for the purpose of determining its object type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the type of the bean, or &#123;<span class="doctag">@code</span> null&#125; if not determinable</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isTypeMatch</span></span><br><span class="line"><span class="comment">	 * 返回给定名称bean的类型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name, <span class="keyword">boolean</span> allowFactoryBeanInit) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the aliases for the given bean name, if any.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;All of those aliases point to the same bean when used in a &#123;<span class="doctag">@link</span> #getBean&#125; call.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If the given name is an alias, the corresponding original bean name</span></span><br><span class="line"><span class="comment">	 * and other aliases (if any) will be returned, with the original bean name</span></span><br><span class="line"><span class="comment">	 * being the first element in the array.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the bean name to check for aliases</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the aliases, or an empty array if none</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">	 * 返回给定bean的别名</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] getAliases(String name);</span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>大数据和Hadoop概述</title>
    <url>/2020/05/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8CHadoop%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/outdoors-5129182_1920.jpg" alt=""></p>
<a id="more"></a>

<h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>大数据：指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。</p>
</blockquote>
<h3 id="大数据部门组织结构"><a href="#大数据部门组织结构" class="headerlink" title="大数据部门组织结构"></a>大数据部门组织结构</h3><p><img src="http://oss.forestyoung.top/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%83%A8%E9%97%A8%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="大数据技术生态体系"><a href="#大数据技术生态体系" class="headerlink" title="大数据技术生态体系"></a>大数据技术生态体系</h3><p><img src="http://oss.forestyoung.top/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81%E4%BD%93%E7%B3%BB.png" alt=""></p>
<ul>
<li><p>Sqoop：Sqoop是一款开源的工具，主要用于在Hadoop、Hive与传统的数据库(MySql)间进行数据的传递，可以将一个关系型数据库（例如 ：MySQL，Oracle 等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p>
</li>
<li><p>Flume：Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。</p>
</li>
<li><p>Kafka：Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：</p>
<ol>
<li><p>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</p>
</li>
<li><p>高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。</p>
</li>
<li><p>支持通过Kafka服务器和消费机集群来分区消息。</p>
</li>
<li><p>支持Hadoop并行数据加载。</p>
</li>
</ol>
</li>
<li><p>Storm：Storm用于“连续计算”，对数据流做连续查询，在计算时就将结果以流的形式输出给用户。</p>
</li>
<li><p>Spark：Spark是当前最流行的开源大数据内存计算框架。可以基于Hadoop上存储的大数据进行计算</p>
</li>
<li><p>Oozie：Oozie是一个管理Hdoop作业（job）的工作流程调度管理系统。</p>
</li>
<li><p>Hbase：HBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。</p>
</li>
<li><p>Hive：Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
</li>
<li><p>R语言：R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。</p>
</li>
<li><p>Mahout：Apache Mahout是个可扩展的机器学习和数据挖掘库。</p>
</li>
<li><p>ZooKeeper：Zookeeper是Google的Chubby一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、 分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
</li>
</ul>
<h3 id="推荐系统框架图"><a href="#推荐系统框架图" class="headerlink" title="推荐系统框架图"></a>推荐系统框架图</h3><p><img src="http://oss.forestyoung.top/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png" alt=""></p>
<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h3><ul>
<li>Hadoop是一个由Apache基金会所开发的分布式系统基础架构</li>
<li>主要解决，海量数据的存储和海量数据的分析计算问题</li>
<li>广义上来说，Hadoop通常是指一个更广泛的概念——-Hadoop生态圈</li>
</ul>
<h3 id="Hadoop三大发行版本"><a href="#Hadoop三大发行版本" class="headerlink" title="Hadoop三大发行版本"></a>Hadoop三大发行版本</h3><ul>
<li>Apache:最原始最基础版本，对于入门学习最好</li>
<li>Cloudera:在大型互联网企业中用的较多</li>
<li>Hortonworks:文档较好</li>
</ul>
<h3 id="Hadoop的优势"><a href="#Hadoop的优势" class="headerlink" title="Hadoop的优势"></a>Hadoop的优势</h3><ul>
<li>高可靠性：Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。</li>
<li>高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。</li>
<li>高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。</li>
<li>高容错性：能够自动将失败的任务重新分配。</li>
</ul>
<h3 id="Hadoop的组成"><a href="#Hadoop的组成" class="headerlink" title="Hadoop的组成"></a>Hadoop的组成</h3><p><img src="http://oss.forestyoung.top/Hadoop%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB.png" alt=""></p>
<p>包括两个核心组成：</p>
<blockquote>
<p>HDFS:分布式文件系统，存储海量的数据</p>
<p>MapReduce：并行处理框架，实现任务分解和调度</p>
</blockquote>
<h3 id="Hadoop可以用来做什么"><a href="#Hadoop可以用来做什么" class="headerlink" title="Hadoop可以用来做什么"></a>Hadoop可以用来做什么</h3><p>搭建大型数据仓库，PB级数据的存储、处理、分析、统计等业务</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程的挑战</title>
    <url>/2020/05/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/autumn-4875907_1920.jpg" alt=""></p>
<a id="more"></a>

<h3 id="多线程的挑战"><a href="#多线程的挑战" class="headerlink" title="多线程的挑战"></a>多线程的挑战</h3><ul>
<li>上下文切换</li>
<li>死锁</li>
</ul>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><blockquote>
<p>单核处理器也可通过CPU给每个线程分配时间片来实现多线程，因为时间片非常短，让人感觉是多个线程同时执行。</p>
<p>问题：切换过程中需要保存上一个任务的状态以便后面切回时恢复</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">循环次数</th>
<th align="left">串行执行耗时/ms</th>
<th align="left">并发执行耗时/ms</th>
<th align="left">并发比串行快多少</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1万</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">慢</td>
</tr>
<tr>
<td align="left">10万</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">慢</td>
</tr>
<tr>
<td align="left">100万</td>
<td align="left">5</td>
<td align="left">5</td>
<td align="left">差不多</td>
</tr>
<tr>
<td align="left">1000万</td>
<td align="left">9</td>
<td align="left">6</td>
<td align="left">1.5倍</td>
</tr>
<tr>
<td align="left">1亿</td>
<td align="left">54</td>
<td align="left">31</td>
<td align="left">接近1倍</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程问题</tag>
      </tags>
  </entry>
  <entry>
    <title>获取阿里云临时授权访问STStoken</title>
    <url>/2019/03/07/%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%B4%E6%97%B6%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AESTStoken/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/%E8%8E%B7%E5%8F%96STStoken.jpg" alt=""></p>
<a id="more"></a>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.alibabacloud.com/help/zh/doc-detail/27364.htm?spm=a2c63.p38356.b99.35.5c778d840l5Eaw" target="_blank" rel="noopener">阿里云官方文档</a><br><a href="https://help.aliyun.com/document_detail/28788.html?spm=a2c4g.11186623.6.645.7f4a7905JfcrXA" target="_blank" rel="noopener">相关SDK</a></p>
<h3 id="RAM-和-STS-介绍"><a href="#RAM-和-STS-介绍" class="headerlink" title="RAM 和 STS 介绍"></a>RAM 和 STS 介绍</h3><blockquote>
<p>阿里云权限管理机制包括访问控制（Resource Access Management，简称 RAM）和安全凭证管理（Security Token Service，简称 STS），可以根据需求使用不同权限的子账号来访问表格存储，也支持为用户提供访问的临时授权。使用RAM和STS能极大地提高管理的灵活性和安全性。</p>
<p>RAM 的主要作用是控制账号系统的权限。通过使用 RAM 可以将在主账号的权限范围内创建子账号，给不同的子账号分配不同的权限，从而达到授权管理的目的。详情请参见<a href="https://www.alibabacloud.com/help/doc-detail/28627.htm" target="_blank" rel="noopener">访问控制产品帮忙文档</a>。</p>
<p>STS 是一个安全凭证（Token）的管理系统，用来授予临时的访问权限，这样就可以通过 STS 来完成对于临时用户的访问授权。</p>
</blockquote>
<h3 id="STS临时授权访问"><a href="#STS临时授权访问" class="headerlink" title="STS临时授权访问"></a>STS临时授权访问</h3><blockquote>
<p>RAM子账号都是可以长期正常使用的，发生泄露后如果无法及时解除权限，会非常危险。</p>
<p>当开发者的 app 被用户使用之后，用户的数据要写入 ram-test-dev 这个实例。当 app 的用户数据很多时，要求能够安全地授权给众多的 app 用户上传数据，并且保证多个用户之间存储的隔离。</p>
<p>类似这种场景需要临时访问权限，应该使用 STS 来完成。STS 可以指定复杂的策略来对特定的用户进行限制，仅提供最小的权限。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>1.创建和管理角色STS的AssumeRole接口的使用，需要在RAM中创建和管理角色</strong></p>
<p><strong>2.添加相关依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加aliyun-java-sdk的相关依赖 start--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-sts<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加aliyun-java-sdk的相关依赖 end--&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.配置文件中添加所需请求参数</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#阿里云访问控制RAM子账户信息,需要登录阿里云控制台查看(Secret只在创建时可查看,需要做好备份)</span></span><br><span class="line"><span class="meta">aliyun.oss.accessKeyId</span>=<span class="string">#你的accessKeyId</span></span><br><span class="line"><span class="meta">aliyun.oss.accessKeySecret</span>=<span class="string">#你的accessKeySecret</span></span><br><span class="line"><span class="comment">#角色ID，在角色中进行授权，获取相应的权限</span></span><br><span class="line"><span class="meta">aliyun.sts.roleArn</span>=<span class="string">#你的roleArn</span></span><br><span class="line"><span class="comment">#指临时凭证的名称，一般来说建议使用不同的应用程序用户来区分。自定义(可不设置)</span></span><br><span class="line"><span class="meta">aliyun.sts.roleSessionName</span>=<span class="string">test</span></span><br></pre></td></tr></table></figure>

<p><strong>4.示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Token返回结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: young</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018年12月04日 13:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StsTokenVO</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问密钥标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问密钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 安全令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String securityToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StsTokenServiceImpl</span> <span class="keyword">implements</span> <span class="title">StsTokenService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(StsTokenServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;aliyun.oss.accessKeyId&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;aliyun.oss.accessKeySecret&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;aliyun.sts.roleArn&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String roleArn;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;aliyun.sts.roleSessionName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String roleSessionName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token失效时间，单位秒(不设置默认1小时,这里设置5分钟)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// private static final Long durationSeconds= 300L;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENDPOINT = <span class="string">"sts.aliyuncs.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取STStoken接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: StsTokenVO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: young</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2018/12/4 13:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StsTokenVO <span class="title">getStsToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StsTokenVO tokenVO = <span class="keyword">new</span> StsTokenVO();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 添加endpoint（直接使用STS endpoint，前两个参数留空，无需添加region ID）</span></span><br><span class="line">            DefaultProfile.addEndpoint(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"Sts"</span>, ENDPOINT);</span><br><span class="line">            <span class="comment">// 构造default profile（参数留空，无需添加region ID）</span></span><br><span class="line">            IClientProfile profile = DefaultProfile.getProfile(<span class="string">""</span>, accessKeyId, accessKeySecret);</span><br><span class="line">            <span class="comment">// 用profile构造client</span></span><br><span class="line">            DefaultAcsClient client = <span class="keyword">new</span> DefaultAcsClient(profile);</span><br><span class="line">            <span class="keyword">final</span> AssumeRoleRequest request = <span class="keyword">new</span> AssumeRoleRequest();</span><br><span class="line">            request.setMethod(MethodType.POST);</span><br><span class="line">            request.setRoleArn(roleArn);</span><br><span class="line">            request.setRoleSessionName(roleSessionName);</span><br><span class="line">            <span class="comment">// request.setDurationSeconds(durationSeconds);</span></span><br><span class="line">            <span class="comment">// 针对该临时权限可以根据该属性赋予规则，格式为json，没有特殊要求，默认为空</span></span><br><span class="line">            <span class="comment">// request.setPolicy(policy); // Optional</span></span><br><span class="line">            <span class="keyword">final</span> AssumeRoleResponse response = client.getAcsResponse(request);</span><br><span class="line">            AssumeRoleResponse.Credentials credentials = response.getCredentials();</span><br><span class="line">            tokenVO.setAccessKeyId(credentials.getAccessKeyId());</span><br><span class="line">            tokenVO.setAccessKeySecret(credentials.getAccessKeySecret());</span><br><span class="line">            tokenVO.setSecurityToken(credentials.getSecurityToken());</span><br><span class="line">            <span class="keyword">return</span> tokenVO;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"获取阿里云STS临时授权权限失败，错误信息："</span> + e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>代码实现</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>Session过期时间</title>
    <url>/2020/05/17/Session%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/lighthouse-5286823_1920.jpg" alt=""></p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目使用cookie和session实现用户认证，在使用过程中通过设置session的过期时间来达到超时自动退出登录的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * session过期时间15分钟(session默认过期时间为半小时，这里设置15分钟与默认时间区分，防止时间混淆)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TIME = <span class="number">15</span> * <span class="number">60</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Forest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2020/4/28 18:17</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultData <span class="title">login</span><span class="params">(HttpServletRequest request, @RequestBody UserDTO user)</span> </span>&#123;</span><br><span class="line">        ResultData resultData = userService.login(user);</span><br><span class="line">        <span class="keyword">if</span> (resultData.isSucceed()) &#123;</span><br><span class="line">            <span class="comment">// 登录后设置session过期时间半小时</span></span><br><span class="line">            HttpSession session = request.getSession();</span><br><span class="line">            session.setAttribute(<span class="string">"isLogin"</span>, <span class="string">"y"</span>);</span><br><span class="line">            session.setAttribute(<span class="string">"userName"</span>, user.getUserName());</span><br><span class="line">            session.setMaxInactiveInterval(MAX_TIME);</span><br><span class="line">            log.info(<span class="string">"用户:&#123;&#125;登录成功"</span>, user.getUserName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是猜测是不是可以设置过期时间为0或负数来达到使session失效的效果，从而实现退出登录功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.setMaxInactiveInterval(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 或者任意负数</span></span><br><span class="line">session.setMaxInactiveInterval(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>debug发现当调用完登出接口后，session依然存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用户登出</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@author</span> Forest</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@date</span> 2020/5/17 5:36 下午</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"loginOut"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultData <span class="title">loginOut</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">      HttpSession session = request.getSession();</span><br><span class="line">      log.info(<span class="string">"用户：&#123;&#125;登出"</span>, session.getAttribute(<span class="string">"userName"</span>));</span><br><span class="line">      session.setMaxInactiveInterval(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> ResultDataUtils.getSuccessResult(<span class="string">"登出成功"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2>]]></content>
      <categories>
        <category>代码实现</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>开发问题合集</title>
    <url>/2020/05/16/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/tunnel-5122424_1920.jpg" alt=""></p>
<a id="more"></a>

<h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p><a href="https://juejin.im/post/5d9c4c1bf265da5b5d2047a2" target="_blank" rel="noopener">阿里云自建图床</a></p>
<h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><blockquote>
<p>OAuth2是一个基于令牌的安全验证和授权框架，有四种类型的授权：1密码，2客户端凭证，3授权码，4隐式</p>
<p>Access token:令牌，用于访问受保护资源</p>
<p>Refresh token:刷新token，在access token失效时通过refresh token重新获取access token</p>
<p>Expires in:过期前的秒数</p>
<p>流程：用户登入访问授权服务器获取token，拿token请求受保护资源的服务器，受保护资源的服务器请求授权服务器校验token是否有效，有效则允许访问</p>
<p>JWT(JSON WEB Token):目的是为OAuth2令牌提供标准结构</p>
<p>JWT令牌编码使用Base64，由验证服务器签名，保证令牌没有被篡改。</p>
<p>JWT是密码签名的，接收该服务的微服务可以保证令牌的内容是有效的，因此，不需要调用验证服务来确认令牌的内容，因为令牌的签名可以被接收微服务确认，并且内容可以被接收微服务检查</p>
</blockquote>
<p><a href="https://www.cnblogs.com/blowing00/p/4521135.html" target="_blank" rel="noopener">简单介绍 Oauth2.0 原理</a></p>
<p><a href="https://www.c0nblogs.com/blowing00/p/4524132.html" target="_blank" rel="noopener">Access Token 与 Refresh Token</a></p>
<p><a href="https://juejin.im/post/5c1200ece51d4560f0435795" target="_blank" rel="noopener">基于 JWT + Refresh Token 的用户认证实践</a></p>
<p><img src="https://oss.forestyoung.top/refreshtoken%E8%AF%B4%E6%98%8E.png" alt=""></p>
<p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JSON Web Token 入门教程</a></p>
<p><a href="https://www.jianshu.com/p/973d224281e4" target="_blank" rel="noopener">注解</a></p>
<p><a href="https://www.jianshu.com/p/d6bba708100d" target="_blank" rel="noopener">@AliasFor注解</a></p>
<p><a href="https://www.cnblogs.com/fashflying/p/6908028.html" target="_blank" rel="noopener">Spring缓存注解@Cacheable、@CacheEvict、@CachePut使用</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Retention &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the retention policy.</span><br><span class="line">     * @return the retention policy</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RetentionPolicy value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Annotations are to be discarded by the compiler.</span><br><span class="line">     * 批注将被编译器丢弃。编译器处理该类型注解</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Annotations are to be recorded in the class file by the compiler</span><br><span class="line">     * but need not be retained by the VM at run time.  This is the default</span><br><span class="line">     * behavior.</span><br><span class="line">     * 注释将由编译器记录在类文件中，但不必在运行时由VM保留。这是默认的行为。</span><br><span class="line">     * 处理class类型的工具能够处理该类型注解</span><br><span class="line">     *&#x2F;</span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Annotations are to be recorded in the class file by the compiler and</span><br><span class="line">     * retained by the VM at run time, so they may be read reflectively.</span><br><span class="line">     * 注释由编译器记录在类文件中，并在运行时由VM保留，因此可以通过反射方式读取它们。</span><br><span class="line">     * 运行时处理</span><br><span class="line">     * @see java.lang.reflect.AnnotatedElement</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用RUNTIME类型的注解</p>
<ul>
<li>Annotation也是class</li>
<li>所有的Annotation继承自java.lang.annotation.Annotation</li>
<li>使用反射API</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2020/06/18/%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://oss.forestyoung.top/wind-turbine-5163993_1920.jpg" alt=""></p>
<a id="more"></a>

<p><a href="https://blog.csdn.net/jiao_zg/article/details/78911469" target="_blank" rel="noopener">匿名内部类访问局部变量加final修饰的问题</a></p>
<p><a href="https://blog.csdn.net/justry_deng/article/details/80972817" target="_blank" rel="noopener">@RequestBody的使用</a></p>
<p><a href="https://blog.csdn.net/shadow_zed/article/details/73478298" target="_blank" rel="noopener">BigDecimal比较大小问题</a></p>
<p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">MyBatis缓存机制</a></p>
<p><a href="https://www.cnblogs.com/keeya/p/9952700.html" target="_blank" rel="noopener">用AOP拦截自定义注解并获取注解属性与上下文参数（基于Springboot框架）</a></p>
<p><a href="https://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html" target="_blank" rel="noopener">MyBatis拦截器原理探究</a></p>
<p><a href="https://www.cnblogs.com/0201zcr/p/5942748.html#3821492" target="_blank" rel="noopener">分布式锁</a></p>
<p><a href="https://blog.csdn.net/a718515028/article/details/84569875" target="_blank" rel="noopener">@Cacheable注解不生效</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
</search>
